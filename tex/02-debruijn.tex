\chapter{De Bruijn Graphs}

TODO uvod

A de Bruijn graph \citep{de1946combinatorial} is a structure for representing
overlaps between strings.

\begin{definition}{De Bruijn graph.}
A De Bruijn graph is directed graph. 
For given $k$, vertices of de Bruijn graph represent sequences of length $k$
($k$-mers). The edges of de Bruijn graph represent possible overlaps of length $k-1$, i. e. 
if have have an edge $(u, v)$ and vertex $u$ represents $k$-mer $a_1, a_2, \dots, a_k$, then
vertex $v$ represents $k$-mer $a_2, a_3, \dots, a_k, x$ and $k$-mer in vertex $v$ can
follow $k$-mer in vertex $u$.
\end{definition}

Besides application in DNA sequencing, de Bruijn graphs are use
in design of fault tolerant networks \citep{ftndeb} and 
distributed hash tables \citep{koorde}.

\section{De Bruijn Graphs for Sequence Assembly}


De Bruijn graphs used for sequence assembly
\citep{pevzner2001eulerian,Velvet} have few modifications
to accomodate for possibility of reads coming from both strands of DNA.

For each vertex $v$ there is a twin vertex $v^{'}$ which
represents reverse complemented $k$-mer. Union of $v$ and $v^{'}$ is called a block.
During manipulation of De Bruijn graph any change applied to node $v$ is also symetrically
applied to its twin $v^{'}$.
To ensure that some $k$-mer is not the same as its reverse complement, $k$ must be an odd number.

Vertices $u$, $v$ in the de Bruijn graph can be connected by directed arcs if the last
$k-1$ bases of $u$ are same as the first $k-1$ bases in $v$. Also note that
if there is an edge between vertices $u$, $v$, there is an inverted edge between their twins,
i.e. there is an edge from $v^{'}$ to $u^{'}$.

We construct De Bruijn graph from reads in a straighforward way.
We extract every $k$-mer from each read and its reverse complement.
Then we join by edge each pair of $k$-mers which are consecutive in some read.
Some assemblers also record simple statistics that will be useful in later
stages of the assembly process, such as multiplicity of each vertex or edge.

This construction can be done in efficient way by using hash tables, like in Velvet \citep{Velvet}.
There are also space-efficient representations of De Bruijn graphs based on Bloom filters \citep{minia}.

\begin{figure}
  \centerline{\includegraphics[scale=0.5]{../figures/db.pdf}}
  \caption{Example of de Bruijn graph constructed from reads: \texttt{AACA}, \texttt{CTTG}, with $k=2$.}
\end{figure}

After constructing de Bruijn graph the assembly can be represented
as a set of walks in de Bruijn graph. Different assemblers
have different criteria on optimal set of walks in de Bruijn graph. 

One approach is to look for Eulerian path through graph.
Even better approach is to look for
Eulerian superpath -- the path which visits every read, i.e. if some read
is broken into vertices $v_1, v_2, \dots, v_n$, then the Eulerian superpath
should contain $v_1, \dots, v_n$ as subpath.

\begin{definition}{Eulerian superpath problem.}
Given graph $G$ and set of paths $\mathbb{P}$ find path $P$, which contains
every path from $\mathbb{P}$ as subpath.
\end{definition}

Euler assembler \citep{pevzner2001eulerian})solves some instances of Eulerian superpath problem
using simple transformations which transform Eulerian superpath instance to equivalent Eulerian path instance.

Other assemblers like Velvet (\cite{Velvet}) just join vertices which can be joined
unambiguosly, i.e. they join vertices $u$, $v$ is there is an edge from $u$ to $v$ and
it is only edge comming out of $u$ and only edge comming into $v$. After this joining
each vertex represents one contig of the assembly.

\subsection{Handling Sequencing Errors}

Sequencing errors in reads increase complexity of the de Bruijn graph
\citep{pevzner2001eulerian}. The common artefacts in a graph that
appear due to sequencing errors are tips and bubbles
(TODO obrazok). Assemblers like Velvet \citep{Velvet}, ABySS \citep{Abyss} handle
errors directly during the construction of de Bruijn graph by detecting these artefacts
and removing them.

The naive approach would be to remove all $k$-mers with low coverage.
This can be problematic since some sequencing technologies do not produce reads with uniform coverage
and consequently we would remove good low coverage regions and consequently the graph would become disconnected.
Instead several more sophisticated techniques have been proposed to remove
most of the artefacts in de Bruijn graph.

\paragraph{Removing tips.} A tip is chain of vertices disconnected at one end. 
Tips usually represent some local errors in the reads. Their removal is pretty straighforward
and removing them does not destroy connectivity in the graph. But sometimes the tips
could represent correct sequence interupted by a gap in the coverage.
Velvet \citep{Velvet} removes tips, which are at most $2k$ bases long and the edge starting
the tip has lower multiplicity that some other edge in the branching vertex.

\paragraph{Removing bubbles.} Bulles are two or more paths which share start and end vertices
and contain similar sequences.
Such bubbles are typically caused by small error in the middle of the read.
Velvet finds such similar paths using the following algorithm:
It starts breadth first search like algorithm from an arbitrary vertex, but considers higher converage
arcs as shorter. Whenever it encounters previously visited vertex $v$ it tries to find closest common ancestor
of the current path and shortest path to $v$. TODO obrazok. Then it extract seqeunce belonging to both paths and
if these two paths are judged to be similar enough, the longer path is merged into the shorter one. 
 
\bigskip

Other option is to use tools like QUAKE (\cite{Quake}), which try to correct reads
without assembling them. This tools usualy consider $k$-mers with low abundance
as errornous and try to correct them using few simple edits in reads.

After correcting for errors, we usually simplify de Bruijn graph by joining vertices
with unambiguous connection as mentioned above. 
We can use this vertices as a base for forming contigs of the assembly.
Most assemblers goes further and use various heuristics
to incorporate information from long and paired reads.
In the next section we will look more into handling paired reads.

\section{Handling Paired Reads}

De Bruijns graphs do not incorporate any information from paired reads.
In this chapter we describe two options for incorpoating this information:
heuristic postprocessing and paired e Bruijn graphs.

\subsection{Heuristic Postprocessing for Paired Reads}

ABySS (\cite{Abyss}) uses paired reads in the following way:
After initial error correction in De Bruijn graph, we align paired reads
to reasonably long vertices in De Bruijn graph. Two vertices are considered linked
if there are at least $p$ read pairs (usually $p=5$) which join the vertices.
We denote $P_i$ the set of vertices which are linked to vertex $v_i$.
Then we perform search for single unique path from $v_i$ through De Bruijn graph which visits
each vertex from $P_i$. We usualy limit this search by estimated distance from $v_i$ to each element
from $P_i$. This process is performed for each vertex and final consistent paths are stitched to final assembly.

TODO alpaths

\subsection{Paired de Bruijn Graphs}

\citet{Paired} argues that heuristic postprocessing
usually works well is simple cases, but fails when assembly contains
several repeated regions after each other.

He introduces concept concept of paired De Bruijn graphs (\cite{Paired}) to incorporate paired read
information directly into the de Bruijn graph.
In the following we will present the construction of 
paired de Bruijn graph.
For simplicity, we will ignore reverse complements and problems associated with that.

\paragraph{Paired De Bruijn graphs with exact insert sizes.}
Let $k$-bimer be pair of two $k$-mer $(a, b)$. Each vertex represents one $k$-bimer and edges represent
consecutive $k$-bimers similarly as in ordinary De Bruijn graph. 
From each pair of reads we will produce $k$-bimers in straighforward way:
$i$-th $k$-bimer will be created using $i$-th $k$-mer from the first read and $i$-th $k$-mer from the second read.
Edges in graph are given by consecutive pairs of $k$-mers from reads.

The assembly is then created by walking some path through graph where we read one part of $k$-bimers.

\paragraph{Paired De Bruijn graphs with approximate insert sizes.}
Lets assume that insert sizes are from the interval $d \pm \Delta$.
We start by constructing paired De Bruijn graph described in previous paragraph.
The key insight is that if two $k$-bimers $(a, b)$ and $(a, b^{'})$ come from
same location of $a$ then the distance of $b$ and $b^{'}$ in ordinary De Bruijn graph is at most $2\Delta$.

In the next step we will merge all vertices $(a, b)$, $(a, b^{'})$ if there is a path
between $b$ and $b^{'}$ in ordinary De Bruijn graph with length at most $2\Delta$.

\bigskip
Like in the case of ordinary De Bruijn graph we need to deal with errors in reads
and also with insert size outliers. This approach still cannot handle multiple
read libraries with various insert sizes and combination of paired libraries and long reads.
One implementation of this approach is SPAdes (\cite{Spades}).


\section{Correction of long reads with high number of errors}

The new technology used to sequence DNA is Pacbio which produces
rather long reads (up to 20000 bases and more) but with many errors
($15\%$ error rate). There is a need to correct this errors in reasonably
efficient way.

One way to do so is to correct Pacbio reads using shorter reads with smaller
error rate. There are approaches which directly map short read on long reads like
PacbioToCA (\cite{PacbioToCA}). Their downside is that this mapping step
is computationaly very expensive.

One way to speed up this mapping step is to generate De Bruijn graph from short reads
and then attempt to map long reads to paths in this graph. This was implemented
in LoRDEC (\cite{Lordec}).

More specifically, after construction of De Bruijn graph, we remove all vertices
with very low coverage (only to keep $k$-mers without errors). $k$-mers belonging
to De Bruijn graph are called solid, others are called weak.
Then we split each long reads into $k$-mers. Each solid $k$-mer from long read is considered to correct. 
Our goal now is to correct regions between solid $k$-mers. To do so we are trying
to find a path through De Bruijn graph which minimizes edit distance between the path
and the region sequence. 
