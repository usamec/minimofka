\chapter{Evaluating quality of assemblies}

After performing an assembly we can count several
interesting statistics, which can tell us how good the assembly is.

\section{Basic statistics}

\subsection{Statistics based only on assembly}

This statistics summarize the distribution of lengths of contigs.
We give a brief overview of metrics used in QUAST (\cite{Quast}), which
is standard tool for evaluation assemblies.

\begin{itemize}
\item Number of contigs (or number of contigs longer than $x$ -- where usually $x = 1000$).
\item Length of the largest contig.
\item Total length of contigs.
\item $Nx$ (where $0 < x \leq 100$) -- the largest contig length $L$, such that using contigs
of length $\geq L$ accounts for at least $x \%$ of the bases of the assembly.
\end{itemize}

Note that each of this statistics can be "gambled" so comparing assemblies based
on this statistics can be only done when we assume, that assembly software does only
reasonable operations.

\subsection{Statistics based on assembly and reference sequence}

Sometimes (especially during evalution as assembly algorithms) we have access to true sequence
and we can compute various statistics which tell us how many errors are in our assembly.
Calculating these statistics usually starts with aligning assembly and reference genome, which
gives us information in the form:
"Substring of assembly starting at position $a$, ending at position $b$ can be mapped
to the substring of reference genomes starting at $c$, ending at $d$ with $e$ edits."
We called aligned substrings blocks. 

\begin{itemize}
\item No. of missasemblies -- missassembly is usually defined as a positions where
positions of block aligned on the left and block aligned on the right differ in reference
by more that $1000$ bases or this block are on opposite strands of in different chromosomes.
\item No. of missassembled contigs -- nubmer of contigs which contain missassembly.
\item No. of mismatches and indels -- these statistics are interesting in one base differences,
either substitutions or insertions and deletions.
\item $NAx$ -- similar to $Nx$, but before computing this statistic we break
contigs at missassemblies.
\end{itemize}

\section{REAPR}

If we have access to original reads and the assembly we can find locations
of this reads in the assembly and then compute several statistics which
can point out to suspicious regions in the assembly.

There are several tools which do this, one of them is REAPR (\cite{Reapr}) which we describe
in more detail below:

REAPR is designed for working with paired reads, so in the following we will assume that
we have one library of paired reads. REAPR starts by mapping reads to the assembly, i.e. for each read we know locations it the assembly
and the edit distance for this mapping.

After mapping step we can calculate following metrics for each base in the assembly:
\begin{itemize}
\item Read coverage -- how many mapping of reads overlap current position. Low coverage usually indicates assembly error.
\item Type of read coverage -- we can calculate read coverage for specific conditions such as: reads without pairs, reads with pair with wrong orientation,
coverage for reads which map with or without reverse complementing.
\item Read clipping -- sometimes read can be mapped to assembly but a few bases at the end of the reads do not match. We can reads mapped this way as soft-clipped.
At each base we count the number of soft-clipped reads which mapping starts or end at this base. A high read clipping count can be sign of insertion of deletion
in the assembly.
\item Paired coverage -- same as read coverage but we treat properly paired reads as a one long read when calculating coverage.
\item FCD error -- TODO
\end{itemize}

REAPR uses this metrics to calculate score at each base and then breaks assembly at places with low score.

\section{Probability models}

